{"version":3,"sources":["../src/index.ts","../src/payment-instruction.ts","../src/utils/errors.ts","../src/utils/format.ts","../src/utils/paseto.ts","../src/utils/validate.ts"],"sourcesContent":["export * from \"./payment-instruction\";\nexport * from \"./types\";\nexport * from \"./utils\";\n","import * as superstruct from \"superstruct\";\n\nimport {\n  InstructionPayload,\n  ReadOptions,\n  TokenCreateOptions,\n  TokenPayload,\n  TokenPublicKeyOptions,\n  UrlPayload,\n} from \"./types\";\nimport {\n  biggerThanOrEqualZero,\n  biggerThanZero,\n  InvalidKepExpired,\n  InvalidPayload,\n  InvalidQrPaymentKeyId,\n  InvalidQrPaymentKeyIssuer,\n  InvalidQrPaymentToken,\n  isAfterDate,\n  MissingKid,\n  MissingKis,\n  MissingSecretKey,\n  PasetoV4Handler,\n} from \"./utils\";\n\n/**\n * Class to handle payment instruction token (qr-crypto token) creation with payload validation\n *\n * @returns\n * `PaymentInstructionsBuilder`\n *\n * @example\n * ```ts\n * const builder = new PaymentInstructionsBuilder();\n * ```\n */\n\nexport class PaymentInstructionsBuilder {\n  private pasetoHandler: PasetoV4Handler;\n\n  constructor() {\n    this.pasetoHandler = new PasetoV4Handler();\n  }\n\n  /**\n   * Create a QR-Crypto token\n   *\n   * @param data - InstructionPayload | UrlPayload;\n   * @param secretKey - string;\n   * @param options - TokenCreateOptions;\n   * @param [warnings=true]\n   *\n   * @returns\n   * `string`\n   *\n   *\n   * @example\n   * ```ts\n   * const builder = new PaymentInstructionsBuilder();\n   *\n   * await builder.create(\n   *   {\n   *     payment: {\n   *       id: \"payment-id\",\n   *       address: \"crypto-address\",\n   *       network_token: \"ntrc20_tTR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t\",\n   *       is_open: true,\n   *       expires_at: 1739802610209,\n   *     },\n   *   },\n   *   secretKey: \"some-private-secret\",\n   *   {\n   *     issuer: \"client.com\",\n   *     expiresIn: \"1h\",\n   *     keyId: \"key-id-one\",\n   *     keyExpiration: \"2025-12-12T01:00:00.000Z\",\n   *     keyIssuer: \"my-bussines.com\",\n   *   }\n   * });\n   *\n   * returns\n   * ```ts\n   * \"qr-crypto.v4.public....\"\n   * ```\n   */\n  public async create(\n    data: InstructionPayload | UrlPayload,\n    secretKey: string,\n    options: TokenCreateOptions,\n    warnings = true,\n  ) {\n    this.validateParameters({\n      payload: data,\n      secretKey,\n      optionsKey: {\n        keyId: options.keyId,\n        keyIssuer: options.keyIssuer,\n        keyExpiration: options.keyExpiration,\n      },\n    });\n\n    if (warnings && !options?.expiresIn) {\n      console.warn(\n        `\\x1b[33m[WARNING]\\x1b[0m: Field 'expiresIn' not provided in QR-Crypto token creation.\n         It is recommended to set an expiration time.\n         Use default of 10 minutes.`,\n      );\n    }\n\n    const payload = {\n      payload: data,\n      kid: options.keyId,\n      kis: options.keyIssuer,\n      kep: options.keyExpiration,\n    };\n\n    const pasetoToken = await this.pasetoHandler.sign(payload, secretKey, {\n      issuer: options.issuer ?? options.keyIssuer,\n      expiresIn: options?.expiresIn || \"10m\",\n      kid: options.keyId,\n      subject: options?.subject,\n      audience: options?.audience,\n      assertion: options?.assertion,\n    });\n\n    return [\"naspip\", options.keyIssuer, options.keyId, pasetoToken].join(\";\");\n  }\n\n  /**\n   * Validate the payload of the payment instruction or url\n   *\n   * @param payload - InstructionPayload | UrlPayload\n   *\n   * @returns\n   * `void` | `Error`\n   *\n   * @example\n   * ```ts\n   * const builder = new PaymentInstructionsBuilder();\n   *\n   * builder.validatePayload({\n   *   payment: {\n   *     id: \"payment-id\",\n   *     address: \"crypto-address\",\n   *     network_token: ntrc20_tTR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t,\n   *     is_open: true,\n   *     expires_at: 17855465854,\n   *   },\n   * });\n   * ```\n   */\n  public validatePayload(payload: InstructionPayload | UrlPayload) {\n    if (\"url\" in payload) {\n      return this.validateUrlPayload(payload);\n    }\n\n    this.validatePaymentInstructionPayload(payload);\n  }\n\n  private validateParameters({\n    payload,\n    secretKey,\n    optionsKey,\n  }: {\n    payload: InstructionPayload | UrlPayload;\n    secretKey: string;\n    optionsKey: TokenPublicKeyOptions;\n  }) {\n    if (!secretKey) {\n      throw new MissingSecretKey(\"secretKey is required for token creation\");\n    }\n\n    if (!optionsKey.keyId) {\n      throw new MissingKid(\"kid is required for token creation\");\n    }\n\n    if (!optionsKey.keyIssuer) {\n      throw new MissingKis(\"kis is required for token creation\");\n    }\n\n    const isKeyExpired = isAfterDate(\n      new Date().toISOString(),\n      optionsKey.keyExpiration,\n    );\n\n    if (isKeyExpired) {\n      throw new InvalidKepExpired(\"kid is expired for token creation\");\n    }\n\n    this.validatePayload(payload);\n  }\n\n  /*\n   * Instruction Order Schema\n   */\n  private instructionOrderSchema = superstruct.object({\n    total_amount: superstruct.refine(\n      superstruct.string(),\n      \"total_amount\",\n      biggerThanZero,\n    ),\n    coin_code: superstruct.string(),\n    description: superstruct.optional(superstruct.string()),\n    merchant: superstruct.object({\n      name: superstruct.string(),\n      description: superstruct.optional(superstruct.string()),\n      tax_id: superstruct.optional(superstruct.string()),\n      image: superstruct.optional(superstruct.string()),\n      mcc: superstruct.optional(superstruct.string()),\n    }),\n    items: superstruct.optional(\n      superstruct.array(\n        superstruct.object({\n          description: superstruct.string(),\n          amount: superstruct.refine(\n            superstruct.string(),\n            \"amount\",\n            biggerThanOrEqualZero,\n          ),\n          unit_price: superstruct.optional(\n            superstruct.refine(\n              superstruct.string(),\n              \"unit_price\",\n              biggerThanOrEqualZero,\n            ),\n          ),\n          quantity: superstruct.refine(\n            superstruct.number(),\n            \"quantity\",\n            biggerThanZero,\n          ),\n          coin_code: superstruct.string(),\n        }),\n      ),\n    ),\n  });\n\n  /**\n   * Payment Instruction Payload Schema\n   *\n   * @private\n   *\n   */\n  private payloadSchema = superstruct.object({\n    payment: superstruct.object({\n      id: superstruct.string(),\n      address: superstruct.string(),\n      address_tag: superstruct.optional(superstruct.string()),\n      network_token: superstruct.string(),\n      is_open: superstruct.boolean(),\n      amount: superstruct.optional(\n        superstruct.refine(superstruct.string(), \"amount\", biggerThanZero),\n      ),\n      min_amount: superstruct.optional(\n        superstruct.refine(superstruct.string(), \"min_amount\", biggerThanZero),\n      ),\n      max_amount: superstruct.optional(\n        superstruct.refine(superstruct.string(), \"max_amount\", biggerThanZero),\n      ),\n      expires_at: superstruct.integer(),\n    }),\n    order: superstruct.optional(this.instructionOrderSchema),\n  });\n\n  /**\n   * URL Payload Schema\n   *\n   * @private\n   *\n   */\n  private payloadUrlSchema = superstruct.object({\n    url: superstruct.string(),\n    payment_options: superstruct.optional(\n      superstruct.array(superstruct.string()),\n    ),\n    order: superstruct.optional(this.instructionOrderSchema),\n  });\n\n  /**\n   * Validate payload of the payment instruction\n   *\n   * @private\n   * @param payload - InstructionPayload\n   *\n   * @returns\n   * `void` | `Error`\n   */\n  private validatePaymentInstructionPayload(payload: InstructionPayload) {\n    const [errors] = superstruct.validate(payload, this.payloadSchema);\n\n    if (errors) {\n      const [failure] = errors.failures();\n      throw new InvalidPayload(\n        failure?.message ?? \"Payload does not match the expected schema\",\n      );\n    }\n\n    if (!payload.payment.is_open && !payload.payment.amount) {\n      throw new InvalidPayload(\n        \"payment.amount is required when 'is_open' is false\",\n      );\n    }\n  }\n\n  /**\n   * Validate URL Payload\n   *\n   * @private\n   * @param payload - UrlPayload\n   *\n   * @returns\n   * `void` | `Error`\n   */\n  private validateUrlPayload(payload: UrlPayload) {\n    const [errors] = superstruct.validate(payload, this.payloadUrlSchema);\n\n    if (errors) {\n      const [failure] = errors.failures();\n      throw new InvalidPayload(\n        failure?.message ?? \"Payload does not match the expected schema\",\n      );\n    }\n  }\n}\n\n/**\n * Class to handle payment instruction token (qr-crypto token) reading\n *\n * @returns PaymentInstructionsReader\n *\n * @example\n * ```ts\n * const reader = new PaymentInstructionsReader();\n * ```\n */\nexport class PaymentInstructionsReader {\n  private pasetoHandler: PasetoV4Handler;\n\n  constructor() {\n    this.pasetoHandler = new PasetoV4Handler();\n  }\n\n  public decode(qrPayment: string) {\n    const decoded = qrPayment.split(\";\");\n\n    const isValidQr = decoded.length == 4 && decoded[0] == \"naspip\";\n\n    if (!isValidQr) {\n      throw new InvalidQrPaymentToken(\"Invalid naspip token prefix\");\n    }\n\n    const [prefix, keyIssuer, keyId, token] = decoded;\n\n    if (!token) {\n      throw new InvalidQrPaymentToken(\"Invalid naspip token\");\n    }\n\n    return { prefix, keyIssuer, keyId, token };\n  }\n\n  /**\n   * Read a QR payment instruction\n   *\n   * @param qrPayment - QR-Crypto token string\n   * @param publicKey - string\n   * @param options - ConsumeOptions<true> (optional)\n   *\n   * @returns\n   * ```json{\n   *    payload: CompleteResult<InstructionPayload>;\n   *    footer?: Buffer | Record<string, any>;\n   *    version: \"v4\";\n   *    purpose: \"public\";\n   *  }```\n   *\n   *\n   * @example\n   * ```ts\n   * const reader = new PaymentInstructionsReader();\n   *\n   * reader.read({\n   *    qrPayment: \"naspip;keyIssuer;keyId;v4.public....\",\n   *    publicKey: \"some-public-key\",\n   *    issuerDomain: \"qrCrypto.com\",\n   *    options: { subject: \"customer@qrCrypto.com\", audience: \"payer-crypto.com\"}\n   * });\n   *\n   * returns\n   * ```ts\n   * {\n   *   version: \"v4\",\n   *   purpose: \"public\",\n   *   payload: {\n   *    payload: {\n   *      payment: {...},\n   *      order: {....}\n   *    },\n   *    iss: \"qrCrypto.com\",\n   *    iat: \"2024-10-29T21:17:00.000Z\",\n   *    exp: \"2024-10-29T21:25:00.000Z\",\n   *    kid: \"some-kid\",\n   *    kep: \"2025-12-31T00:00:00.000Z\"\n   *    kis: \"some-business.com\"\n   *    sub: \"customer@qrCrypto.com\",\n   *    aud: \"payer-crypto.com\"\n   *   }\n   * }\n   * ```\n   */\n  public async read({\n    qrPayment,\n    publicKey,\n    options,\n  }: {\n    qrPayment: string;\n    publicKey: string;\n    options?: ReadOptions;\n  }) {\n    const decodedQr = this.decode(qrPayment);\n\n    const data = await this.pasetoHandler.verify<TokenPayload>(\n      decodedQr.token,\n      publicKey,\n      {\n        ...options,\n        complete: true,\n        ignoreExp: false,\n        ignoreIat: false,\n        assertion: publicKey,\n      },\n    );\n\n    if (options?.keyId && options.keyId !== data.payload.kid) {\n      throw new InvalidQrPaymentKeyId(\"Invalid Key ID\");\n    }\n\n    if (options?.keyIssuer && options.keyIssuer !== data.payload.kis) {\n      throw new InvalidQrPaymentKeyIssuer(\"Invalid Key Issuer\");\n    }\n\n    if (\n      !options?.ignoreKeyExp &&\n      isAfterDate(new Date().toISOString(), data.payload.kep)\n    ) {\n      throw new InvalidQrPaymentKeyIssuer(\"Invalid Key Issuer\");\n    }\n\n    return data;\n  }\n}\n","const CODES = {\n  InvalidPayload: \"ERR_INVALID_PAYLOAD\",\n  MissingSecretKey: \"ERR_MISSING_SECRET_KEY\",\n  MissingKid: \"ERR_MISSING_KEY_ID\",\n  MissingKis: \"ERR_MISSING_KEY_ISSUER\",\n  InvalidKepExpired: \"ERR_KEY_ID_IS_EXPIRED\",\n  InvalidQrPaymentToken: \"ERR_INVALID_QR_PAYMENT_TOKEN\",\n  InvalidQrPaymentKeyId: \"ERR_INVALID_QR_PAYMENT_KID\",\n  InvalidQrPaymentKeyIssuer: \"ERR_INVALID_QR_PAYMENT_KIS\",\n  InvalidQrPaymentKeyExpired: \"ERR_INVALID_QR_PAYMENT_KEP\",\n} as const;\n\nexport class PayInsError extends Error {\n  public code: string;\n\n  constructor(message: string, noColor = false) {\n    super(message);\n    this.name = noColor\n      ? \"[ERROR] \" + this.constructor.name\n      : \"\\x1b[31m[ERROR]\\x1b[0m \" + this.constructor.name;\n    this.code = CODES[this.constructor.name as keyof typeof CODES];\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nexport class InvalidPayload extends PayInsError {}\nexport class MissingSecretKey extends PayInsError {}\nexport class MissingKid extends PayInsError {}\nexport class MissingKis extends PayInsError {}\nexport class InvalidKepExpired extends PayInsError {}\nexport class InvalidQrPaymentToken extends PayInsError {}\nexport class InvalidQrPaymentKeyId extends PayInsError {}\nexport class InvalidQrPaymentKeyIssuer extends PayInsError {}\nexport class InvalidQrPaymentKeyExpired extends PayInsError {}\n","export function isAfterDate(date1: string, date2: string) {\n  return new Date(date1) > new Date(date2);\n}\n","import { ConsumeOptions, decode, ProduceOptions, V4 } from \"paseto\";\n\ntype AsymetricKey = \"paserk\";\ntype PasetoTokenContext = \"public\";\n\nexport class PasetoV4Handler {\n  /*\n\n*/\n\n  /**\n   * Generate asymetric public/private key\n   *\n   * @param purpose - Only support \"public\"\n   * @param options - Only support { format: \"paserk\" }\n   *\n   * @returns\n   * `{ secretKey: string; publicKey: string; }`\n   *\n   *\n   * @example\n   * ```ts\n   * PasetoV4Handler.generateKey(\"public\", { format: \"paserk\" });\n   *\n   * returns\n   * {\n   *   secretKey: 'k4.secret.ICXpik-1FLvjjvspZuFpzudF2WMkjsmBECOkjlNR6lb7C_pYpZkYoB6wW0RTVQTSKNO2kYrL55lxnctEY6fabw',\n   *   publicKey: 'k4.public.-wv6WKWZGKAesFtEU1UE0ijTtpGKy-eZcZ3LRGOn2m8'\n   * }\n   *\n   * ```\n   */\n  public static async generateKey(\n    purpose: PasetoTokenContext,\n    options: { format: AsymetricKey },\n  ) {\n    return V4.generateKey(purpose, options);\n  }\n\n  /**\n   * Decode paseto token\n   *\n   * @param token - paseto token\n   * @returns\n   * `{ ...data, footer: string | Record<string, any> }`\n   */\n\n  public decode(token: string) {\n    const data = decode(token);\n\n    try {\n      const footer = JSON.parse(data.footer?.toString() ?? \"\");\n      return { ...data, footer };\n    } catch {\n      //\n    }\n\n    return { ...data, footer: data.footer?.toString() };\n  }\n\n  /**\n   *\n   * @remarks\n   * Claims reserved\n   *\n   * | Key |    Name        |  Type  |             Example                 |\n   *\n   * | iss |   Issuer       | string |       {\"iss\":\"paragonie.com\"}       |\n   *\n   * | sub |  Subject       | string |            {\"sub\":\"test\"}           |\n   *\n   * | aud |  Audience      | string |       {\"aud\":\"pie-hosted.com\"}      |\n   *\n   * | exp | Expiration     | DtTime | {\"exp\":\"2039-01-01T00:00:00+00:00\"} |\n   *\n   * | nbf | Not Before     | DtTime | {\"nbf\":\"2038-04-01T00:00:00+00:00\"} |\n   *\n   * | iat | Issued At      | DtTime | {\"iat\":\"2038-03-17T00:00:00+00:00\"} |\n   *\n   * | jti |  Token ID      | string |  {\"jti\":\"87IFSGFgPNtQNNuw0AtuLttP\"} |\n   *\n   * | kid |   Key-ID       | string |    {\"kid\":\"stored-in-the-footer\"}   |\n   *\n   * | kis | Key-Issuer     | string |    {\"kis\":\"my-issuer.com\"}          |\n   *\n   * | kep | Key-Expiration | DtTime | {\"kep\":\"2038-03-17T00:00:00+00:00\"} |\n   *\n   *\n   * @param payload - a Record with data to sign\n   * @param privateKey - private key as string\n   * @param options - options for paseto v4 algorimth\n   * @returns\n   * Paseto V4 public token format.\n   */\n  public async sign(\n    payload: Record<string, any>,\n    privateKey: string,\n    options?: ProduceOptions,\n  ) {\n    return V4.sign(payload, privateKey, options);\n  }\n\n  /**\n   * Verify paseto token\n   *\n   * @param token - paseto token\n   * @param publicKey - public key as string\n   * @param options - options for paseto v4 algorimth\n   * @returns\n   * Paseto V4 public token format.\n   */\n  public async verify<Payload>(\n    token: string,\n    publicKey: string,\n    options?: ConsumeOptions<true>,\n  ) {\n    return V4.verify<Payload>(token, publicKey, options);\n  }\n}\n","export function biggerThanZero(value: string | number) {\n  return parseFloat(value.toString()) > 0;\n}\n\nexport function biggerThanOrEqualZero(value: string) {\n  return parseFloat(value) >= 0;\n}\n"],"mappings":"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","names":["CODES","InvalidPayload","MissingSecretKey","MissingKid","MissingKis","InvalidKepExpired","InvalidQrPaymentToken","InvalidQrPaymentKeyId","InvalidQrPaymentKeyIssuer","InvalidQrPaymentKeyExpired","PayInsError","Error","code","constructor","message","noColor","name","captureStackTrace","isAfterDate","date1","date2","Date","PasetoV4Handler","generateKey","purpose","options","V4","decode","token","data","footer","JSON","parse","toString","sign","payload","privateKey","verify","publicKey","biggerThanZero","value","parseFloat","toString","biggerThanOrEqualZero","PaymentInstructionsBuilder","pasetoHandler","constructor","PasetoV4Handler","create","data","secretKey","options","warnings","validateParameters","payload","optionsKey","keyId","keyIssuer","keyExpiration","expiresIn","console","warn","kid","kis","kep","pasetoToken","sign","issuer","subject","audience","assertion","join","validatePayload","validateUrlPayload","validatePaymentInstructionPayload","MissingSecretKey","MissingKid","MissingKis","isKeyExpired","isAfterDate","Date","toISOString","InvalidKepExpired","instructionOrderSchema","object","total_amount","refine","string","biggerThanZero","coin_code","description","optional","merchant","name","tax_id","image","mcc","items","array","amount","biggerThanOrEqualZero","unit_price","quantity","number","payloadSchema","payment","id","address","address_tag","network_token","is_open","boolean","min_amount","max_amount","expires_at","integer","order","payloadUrlSchema","url","payment_options","errors","validate","failure","failures","InvalidPayload","message","PaymentInstructionsReader","decode","qrPayment","decoded","split","isValidQr","length","InvalidQrPaymentToken","prefix","token","read","publicKey","decodedQr","verify","complete","ignoreExp","ignoreIat","InvalidQrPaymentKeyId","InvalidQrPaymentKeyIssuer","ignoreKeyExp"]}