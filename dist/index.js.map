{"version":3,"sources":["../src/index.ts","../src/payment-instruction.ts","../src/types.ts","../src/utils/errors.ts","../src/data/networks.ts","../src/utils/format.ts","../src/utils/paseto.ts","../src/utils/validate.ts"],"sourcesContent":["export * from \"./payment-instruction\";\nexport * from \"./types\";\nexport * from \"./utils\";\n","import * as superstruct from \"superstruct\";\n\nimport {\n  InstructionPayload,\n  NetworkCode,\n  ReadOptions,\n  TokenCreateOptions,\n  TokenPayload,\n  TokenPublicKeyOptions,\n  UrlPayload,\n} from \"./types\";\nimport {\n  biggerThanOrEqualZero,\n  biggerThanZero,\n  InvalidKepExpired,\n  InvalidPayload,\n  InvalidQrCryptoKeyId,\n  InvalidQrCryptoKeyIssuer,\n  InvalidQrCryptoToken,\n  isAfterDate,\n  MissingKid,\n  MissingKis,\n  MissingSecretKey,\n  PasetoV4Handler,\n} from \"./utils\";\n\n/**\n * Class to handle payment instruction token (qr-crypto token) creation with payload validation\n *\n * @returns\n * `PaymentInstructionsBuilder`\n *\n * @example\n * ```ts\n * const builder = new PaymentInstructionsBuilder();\n * ```\n */\n\nexport class PaymentInstructionsBuilder {\n  private pasetoHandler: PasetoV4Handler;\n\n  constructor() {\n    this.pasetoHandler = new PasetoV4Handler();\n  }\n\n  /**\n   * Create a QR-Crypto token\n   *\n   * @param data - InstructionPayload | UrlPayload;\n   * @param secretKey - string;\n   * @param options - TokenCreateOptions;\n   * @param [warnings=true]\n   *\n   * @returns\n   * `string`\n   *\n   *\n   * @example\n   * ```ts\n   * const builder = new PaymentInstructionsBuilder();\n   *\n   * await builder.create(\n   *   {\n   *     payment: {\n   *       id: \"payment-id\",\n   *       address: \"crypto-address\",\n   *       network: NetworkCode.TRON,\n   *       coin: CoinCode.TRON_USDT,\n   *       is_open: true,\n   *     },\n   *   },\n   *   secretKey: \"some-private-secret\",\n   *   {\n   *     issuer: \"client.com\",\n   *     expiresIn: \"1h\",\n   *     keyId: \"key-id-one\",\n   *     keyExpiration: \"2025-12-12T01:00:00.000Z\",\n   *     keyIssuer: \"my-bussines.com\",\n   *   }\n   * });\n   *\n   * returns\n   * ```ts\n   * \"qr-crypto.v4.public....\"\n   * ```\n   */\n  public async create(\n    data: InstructionPayload | UrlPayload,\n    secretKey: string,\n    options: TokenCreateOptions,\n    warnings = true,\n  ) {\n    this.validateParameters({\n      payload: data,\n      secretKey,\n      optionsKey: {\n        keyId: options.keyId,\n        keyIssuer: options.keyIssuer,\n        keyExpiration: options.keyExpiration,\n      },\n    });\n\n    if (warnings && !options?.expiresIn) {\n      console.warn(\n        `\\x1b[33m[WARNING]\\x1b[0m: Field 'expiresIn' not provided in QR-Crypto token creation.\n         It is recommended to set an expiration time.\n         Use default of 10 minutes.`,\n      );\n    }\n\n    const payload = {\n      payload: data,\n      kid: options.keyId,\n      kis: options.keyIssuer,\n      kep: options.keyExpiration,\n    };\n\n    const pasetoToken = await this.pasetoHandler.sign(payload, secretKey, {\n      issuer: options.issuer ?? options.keyIssuer,\n      expiresIn: options?.expiresIn || \"10m\",\n      kid: options.keyId,\n      subject: options?.subject,\n      audience: options?.audience,\n      assertion: options?.assertion,\n    });\n\n    return `qr-crypto.${pasetoToken}`;\n  }\n\n  /**\n   * Validate the payload of the payment instruction or url\n   *\n   * @param payload - InstructionPayload | UrlPayload\n   *\n   * @returns\n   * `void` | `Error`\n   *\n   * @example\n   * ```ts\n   * const builder = new PaymentInstructionsBuilder();\n   *\n   * builder.validatePayload({\n   *   payment: {\n   *     id: \"payment-id\",\n   *     address: \"crypto-address\",\n   *     network: NetworkCode.TRON,\n   *     coin: CoinCode.TRON_USDT,\n   *     is_open: true,\n   *   },\n   * });\n   * ```\n   */\n  public validatePayload(payload: InstructionPayload | UrlPayload) {\n    if (\"url\" in payload) {\n      return this.validateUrlPayload(payload);\n    }\n\n    this.validatePaymentInstructionPayload(payload);\n  }\n\n  private validateParameters({\n    payload,\n    secretKey,\n    optionsKey,\n  }: {\n    payload: InstructionPayload | UrlPayload;\n    secretKey: string;\n    optionsKey: TokenPublicKeyOptions;\n  }) {\n    if (!secretKey) {\n      throw new MissingSecretKey(\"secretKey is required for token creation\");\n    }\n\n    if (!optionsKey.keyId) {\n      throw new MissingKid(\"kid is required for token creation\");\n    }\n\n    if (!optionsKey.keyIssuer) {\n      throw new MissingKis(\"kis is required for token creation\");\n    }\n\n    const isKeyExpired = isAfterDate(\n      new Date().toISOString(),\n      optionsKey.keyExpiration,\n    );\n\n    if (isKeyExpired) {\n      throw new InvalidKepExpired(\"kid is expired for token creation\");\n    }\n\n    this.validatePayload(payload);\n  }\n\n  /**\n   * Payment Instruction Payload Schema\n   *\n   * @private\n   *\n   */\n  private payloadSchema = superstruct.object({\n    payment: superstruct.object({\n      id: superstruct.string(),\n      address: superstruct.string(),\n      address_tag: superstruct.optional(superstruct.string()),\n      network: superstruct.enums(Object.values(NetworkCode)),\n      coin: superstruct.string(),\n      is_open: superstruct.boolean(),\n      amount: superstruct.optional(\n        superstruct.refine(superstruct.string(), \"amount\", biggerThanZero),\n      ),\n      min_amount: superstruct.optional(\n        superstruct.refine(superstruct.string(), \"min_amount\", biggerThanZero),\n      ),\n      max_amount: superstruct.optional(\n        superstruct.refine(superstruct.string(), \"max_amount\", biggerThanZero),\n      ),\n    }),\n    order: superstruct.optional(\n      superstruct.object({\n        total_amount: superstruct.refine(\n          superstruct.string(),\n          \"total_amount\",\n          biggerThanZero,\n        ),\n        coin_code: superstruct.string(),\n        description: superstruct.optional(superstruct.string()),\n        merchant: superstruct.object({\n          name: superstruct.string(),\n          description: superstruct.optional(superstruct.string()),\n          tax_id: superstruct.optional(superstruct.string()),\n          image_url: superstruct.optional(superstruct.string()),\n        }),\n        items: superstruct.refine(\n          superstruct.array(\n            superstruct.object({\n              title: superstruct.string(),\n              description: superstruct.optional(superstruct.string()),\n              amount: superstruct.refine(\n                superstruct.string(),\n                \"amount\",\n                biggerThanOrEqualZero,\n              ),\n              unit_price: superstruct.optional(\n                superstruct.refine(\n                  superstruct.string(),\n                  \"unit_price\",\n                  biggerThanOrEqualZero,\n                ),\n              ),\n              quantity: superstruct.refine(\n                superstruct.number(),\n                \"quantity\",\n                biggerThanZero,\n              ),\n              coin_code: superstruct.string(),\n              image_url: superstruct.optional(superstruct.string()),\n            }),\n          ),\n          \"items\",\n          (value) => value.length > 0,\n        ),\n      }),\n    ),\n  });\n\n  /**\n   * URL Payload Schema\n   *\n   * @private\n   *\n   */\n  private payloadUrlSchema = superstruct.object({\n    url: superstruct.string(),\n  });\n\n  /**\n   * Validate payload of the payment instruction\n   *\n   * @private\n   * @param payload - InstructionPayload\n   *\n   * @returns\n   * `void` | `Error`\n   */\n  private validatePaymentInstructionPayload(payload: InstructionPayload) {\n    const [errors] = superstruct.validate(payload, this.payloadSchema);\n\n    if (errors) {\n      const [failure] = errors.failures();\n      throw new InvalidPayload(\n        failure?.message ?? \"Payload does not match the expected schema\",\n      );\n    }\n\n    if (!payload.payment.is_open && !payload.payment.amount) {\n      throw new InvalidPayload(\n        \"payment.amount is required when 'is_open' is false\",\n      );\n    }\n  }\n\n  /**\n   * Validate URL Payload\n   *\n   * @private\n   * @param payload - UrlPayload\n   *\n   * @returns\n   * `void` | `Error`\n   */\n  private validateUrlPayload(payload: UrlPayload) {\n    const [errors] = superstruct.validate(payload, this.payloadUrlSchema);\n\n    if (errors) {\n      const [failure] = errors.failures();\n      throw new InvalidPayload(\n        failure?.message ?? \"Payload does not match the expected schema\",\n      );\n    }\n  }\n}\n\n/**\n * Class to handle payment instruction token (qr-crypto token) reading\n *\n * @returns PaymentInstructionsReader\n *\n * @example\n * ```ts\n * const reader = new PaymentInstructionsReader();\n * ```\n */\nexport class PaymentInstructionsReader {\n  private pasetoHandler: PasetoV4Handler;\n\n  constructor() {\n    this.pasetoHandler = new PasetoV4Handler();\n  }\n\n  /**\n   * Read a QR-Crypto payment instruction\n   *\n   * @param qrCrypto - QR-Crypto token string\n   * @param publicKey - string\n   * @param options - ConsumeOptions<true> (optional)\n   *\n   * @returns\n   * ```json{\n   *    payload: CompleteResult<InstructionPayload>;\n   *    footer?: Buffer | Record<string, any>;\n   *    version: \"v4\";\n   *    purpose: \"public\";\n   *  }```\n   *\n   *\n   * @example\n   * ```ts\n   * const reader = new PaymentInstructionsReader();\n   *\n   * reader.read({\n   *    qrCrypto: \"qr-crypto.v4.public....\",\n   *    publicKey: \"some-public-key\",\n   *    issuerDomain: \"qrCrypto.com\",\n   *    options: { subject: \"customer@qrCrypto.com\", audience: \"payer-crypto.com\"}\n   * });\n   *\n   * returns\n   * ```ts\n   * {\n   *   version: \"v4\",\n   *   purpose: \"public\",\n   *   payload: {\n   *    payload: {\n   *      payment: {...},\n   *      order: {....}\n   *    },\n   *    iss: \"qrCrypto.com\",\n   *    iat: \"2024-10-29T21:17:00.000Z\",\n   *    exp: \"2024-10-29T21:25:00.000Z\",\n   *    kid: \"some-kid\",\n   *    kep: \"2025-12-31T00:00:00.000Z\"\n   *    kis: \"some-business.com\"\n   *    sub: \"customer@qrCrypto.com\",\n   *    aud: \"payer-crypto.com\"\n   *   }\n   * }\n   * ```\n   */\n  public async read({\n    qrCrypto,\n    publicKey,\n    options,\n  }: {\n    qrCrypto: string;\n    publicKey: string;\n    options?: ReadOptions;\n  }) {\n    const isValidQr = qrCrypto.startsWith(\"qr-crypto.\");\n    if (!isValidQr) {\n      throw new InvalidQrCryptoToken(\"Invalid 'qr-crypto' token prefix\");\n    }\n\n    const token = qrCrypto.slice(10);\n\n    const data = await this.pasetoHandler.verify<TokenPayload>(\n      token,\n      publicKey,\n      {\n        ...options,\n        complete: true,\n        ignoreExp: false,\n        ignoreIat: false,\n        assertion: publicKey,\n      },\n    );\n\n    if (options?.keyId && options.keyId !== data.payload.kid) {\n      throw new InvalidQrCryptoKeyId(\"Invalid Key ID\");\n    }\n\n    if (options?.keyIssuer && options.keyIssuer !== data.payload.kis) {\n      throw new InvalidQrCryptoKeyIssuer(\"Invalid Key Issuer\");\n    }\n\n    if (\n      !options?.ignoreKeyExp &&\n      isAfterDate(new Date().toISOString(), data.payload.kep)\n    ) {\n      throw new InvalidQrCryptoKeyIssuer(\"Invalid Key Issuer\");\n    }\n\n    return data;\n  }\n}\n","import { ConsumeOptions } from \"paseto\";\n\nexport enum NetworkCode {\n  BSC = \"BSC\",\n  BITCOIN = \"BITCOIN\",\n  ERC20 = \"ERC20\",\n  LIGHTNING = \"LIGHTNING\",\n  LITECOIN = \"LITECOIN\",\n  POLYGON = \"POLYGON\",\n  SOLANA = \"SOLANA\",\n  TRON = \"TRON\",\n  STELLAR = \"STELLAR\",\n}\n\nexport enum CoinCode {\n  TRON_USDT = \"TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t\",\n  POLYGON_USDT = \"0xc2132d05d31c914a87c6611c10748aeb04b58e8f\",\n  POLYGON_USDC = \"0x3c499c542cef5e3811e1192ce70d8cc03d5c3359\",\n}\n\nexport interface UrlPayload {\n  url: string;\n}\n\nexport interface InstructionPayload {\n  payment: InstructionPayment;\n  order?: InstructionOrder;\n}\n\nexport interface InstructionPayment {\n  id: string;\n  address: string;\n  address_tag?: string;\n  network: NetworkCode;\n  coin: CoinCode; // [token SC/address, ISO 4217]\n  is_open: boolean;\n  amount?: string;\n  min_amount?: string;\n  max_amount?: string;\n}\n\nexport interface InstructionMerchant {\n  name: string;\n  description?: string;\n  tax_id?: string;\n  image_url?: string;\n}\n\nexport interface InstructionOrder {\n  total_amount: string;\n  coin_code: string; // [token SC/address, ISO 4217]\n  description?: string;\n  items?: InstructionItem[];\n  merchant?: InstructionMerchant;\n}\n\nexport interface InstructionItem {\n  title: string;\n  description?: string;\n  amount: string;\n  unit_price?: string;\n  quantity?: number;\n  coin_code: string;\n  image_url?: string;\n}\n\nexport interface TokenPayload {\n  iss: string;\n  sub?: string;\n  aud?: string;\n  iat: string;\n  exp: string;\n  nbf?: string;\n  jti?: string;\n  kid: string;\n  kep: string;\n  kis: string;\n  payload: InstructionPayload | UrlPayload;\n}\n\nexport interface TokenCreateOptions extends TokenPublicKeyOptions {\n  issuer?: string;\n  expiresIn: string;\n  subject?: string;\n  audience?: string;\n  assertion?: string;\n}\n\nexport interface TokenPublicKeyOptions {\n  keyId: string;\n  keyExpiration: string;\n  keyIssuer: string;\n}\n\nexport interface ReadOptions extends ConsumeOptions<true> {\n  keyId?: string;\n  keyIssuer?: string;\n  ignoreKeyExp?: boolean;\n}\n","const CODES = {\n  InvalidPayload: \"ERR_INVALID_PAYLOAD\",\n  MissingSecretKey: \"ERR_MISSING_SECRET_KEY\",\n  MissingKid: \"ERR_MISSING_KEY_ID\",\n  MissingKis: \"ERR_MISSING_KEY_ISSUER\",\n  InvalidKepExpired: \"ERR_KEY_ID_IS_EXPIRED\",\n  InvalidQrCryptoToken: \"ERR_INVALID_QR_CRYPTO_TOKEN\",\n  InvalidQrCryptoKeyId: \"ERR_INVALID_QR_CRYPTO_KID\",\n  InvalidQrCryptoKeyIssuer: \"ERR_INVALID_QR_CRYPTO_KIS\",\n  InvalidQrCryptoKeyExpired: \"ERR_INVALID_QR_CRYPTO_KEP\",\n} as const;\n\nexport class PayInsError extends Error {\n  public code: string;\n\n  constructor(message: string, noColor = false) {\n    super(message);\n    this.name = noColor\n      ? \"[ERROR] \" + this.constructor.name\n      : \"\\x1b[31m[ERROR]\\x1b[0m \" + this.constructor.name;\n    this.code = CODES[this.constructor.name as keyof typeof CODES];\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nexport class InvalidPayload extends PayInsError {}\nexport class MissingSecretKey extends PayInsError {}\nexport class MissingKid extends PayInsError {}\nexport class MissingKis extends PayInsError {}\nexport class InvalidKepExpired extends PayInsError {}\nexport class InvalidQrCryptoToken extends PayInsError {}\nexport class InvalidQrCryptoKeyId extends PayInsError {}\nexport class InvalidQrCryptoKeyIssuer extends PayInsError {}\nexport class InvalidQrCryptoKeyExpired extends PayInsError {}\n","export const networkDataMap = {\n  BSC: { network: \"BSC\", name: \"BNB Smart Chain (BEP20)\" },\n  BITCOIN: { network: \"BITCOIN\", name: \"Bitcoin\" },\n  ERC20: { network: \"ERC20\", name: \"Ethereum (ERC20)\" },\n  LIGHTNING: { network: \"LIGHTNING\", name: \"Lightning Network\" },\n  LITECOIN: { network: \"LITECOIN\", name: \"Litecoin\" },\n  POLYGON: { network: \"POLYGON\", name: \"Polygon POS\" },\n  SOLANA: { network: \"SOLANA\", name: \"Solana\" },\n  TRON: { network: \"TRON\", name: \"Tron (TRC20)\" },\n  STELLAR: { network: \"STELLAR\", name: \"Stellar Network\" },\n};\n","import { networkDataMap } from \"../data\";\nimport { NetworkCode } from \"../types\";\n\nexport function getNetworkData(network: string | NetworkCode) {\n  return networkDataMap[network] ?? { network, name: network };\n}\n\nexport function isAfterDate(date1: string, date2: string) {\n  return new Date(date1) > new Date(date2);\n}\n","import { ConsumeOptions, decode, ProduceOptions, V4 } from \"paseto\";\n\ntype AsymetricKey = \"paserk\";\ntype PasetoTokenContext = \"public\";\n\nexport class PasetoV4Handler {\n  /*\n\n*/\n\n  /**\n   * Generate asymetric public/private key\n   *\n   * @param purpose - Only support \"public\"\n   * @param options - Only support { format: \"paserk\" }\n   *\n   * @returns\n   * `{ secretKey: string; publicKey: string; }`\n   *\n   *\n   * @example\n   * ```ts\n   * PasetoV4Handler.generateKey(\"public\", { format: \"paserk\" });\n   *\n   * returns\n   * {\n   *   secretKey: 'k4.secret.ICXpik-1FLvjjvspZuFpzudF2WMkjsmBECOkjlNR6lb7C_pYpZkYoB6wW0RTVQTSKNO2kYrL55lxnctEY6fabw',\n   *   publicKey: 'k4.public.-wv6WKWZGKAesFtEU1UE0ijTtpGKy-eZcZ3LRGOn2m8'\n   * }\n   *\n   * ```\n   */\n  public static async generateKey(\n    purpose: PasetoTokenContext,\n    options: { format: AsymetricKey },\n  ) {\n    return V4.generateKey(purpose, options);\n  }\n\n  /**\n   * Decode paseto token\n   *\n   * @param token - paseto token\n   * @returns\n   * `{ ...data, footer: string | Record<string, any> }`\n   */\n\n  public decode(token: string) {\n    const data = decode(token);\n\n    try {\n      const footer = JSON.parse(data.footer?.toString() ?? \"\");\n      return { ...data, footer };\n    } catch {\n      //\n    }\n\n    return { ...data, footer: data.footer?.toString() };\n  }\n\n  /**\n   *\n   * @remarks\n   * Claims reserved\n   *\n   * | Key |    Name        |  Type  |             Example                 |\n   *\n   * | iss |   Issuer       | string |       {\"iss\":\"paragonie.com\"}       |\n   *\n   * | sub |  Subject       | string |            {\"sub\":\"test\"}           |\n   *\n   * | aud |  Audience      | string |       {\"aud\":\"pie-hosted.com\"}      |\n   *\n   * | exp | Expiration     | DtTime | {\"exp\":\"2039-01-01T00:00:00+00:00\"} |\n   *\n   * | nbf | Not Before     | DtTime | {\"nbf\":\"2038-04-01T00:00:00+00:00\"} |\n   *\n   * | iat | Issued At      | DtTime | {\"iat\":\"2038-03-17T00:00:00+00:00\"} |\n   *\n   * | jti |  Token ID      | string |  {\"jti\":\"87IFSGFgPNtQNNuw0AtuLttP\"} |\n   *\n   * | kid |   Key-ID       | string |    {\"kid\":\"stored-in-the-footer\"}   |\n   *\n   * | kis | Key-Issuer     | string |    {\"kis\":\"my-issuer.com\"}          |\n   *\n   * | kep | Key-Expiration | DtTime | {\"kep\":\"2038-03-17T00:00:00+00:00\"} |\n   *\n   *\n   * @param payload - a Record with data to sign\n   * @param privateKey - private key as string\n   * @param options - options for paseto v4 algorimth\n   * @returns\n   * Paseto V4 public token format.\n   */\n  public async sign(\n    payload: Record<string, any>,\n    privateKey: string,\n    options?: ProduceOptions,\n  ) {\n    return V4.sign(payload, privateKey, options);\n  }\n\n  /**\n   * Verify paseto token\n   *\n   * @param token - paseto token\n   * @param publicKey - public key as string\n   * @param options - options for paseto v4 algorimth\n   * @returns\n   * Paseto V4 public token format.\n   */\n  public async verify<Payload>(\n    token: string,\n    publicKey: string,\n    options?: ConsumeOptions<true>,\n  ) {\n    return V4.verify<Payload>(token, publicKey, options);\n  }\n}\n","export function biggerThanZero(value: string | number) {\n  return parseFloat(value.toString()) > 0;\n}\n\nexport function biggerThanOrEqualZero(value: string) {\n  return parseFloat(value) >= 0;\n}\n"],"mappings":"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","names":["NetworkCode","CoinCode","CODES","InvalidPayload","MissingSecretKey","MissingKid","MissingKis","InvalidKepExpired","InvalidQrCryptoToken","InvalidQrCryptoKeyId","InvalidQrCryptoKeyIssuer","InvalidQrCryptoKeyExpired","PayInsError","Error","code","constructor","message","noColor","name","captureStackTrace","networkDataMap","BSC","network","name","BITCOIN","ERC20","LIGHTNING","LITECOIN","POLYGON","SOLANA","TRON","STELLAR","getNetworkData","network","networkDataMap","name","isAfterDate","date1","date2","Date","PasetoV4Handler","generateKey","purpose","options","V4","decode","token","data","footer","JSON","parse","toString","sign","payload","privateKey","verify","publicKey","biggerThanZero","value","parseFloat","toString","biggerThanOrEqualZero","PaymentInstructionsBuilder","pasetoHandler","constructor","PasetoV4Handler","create","data","secretKey","options","warnings","validateParameters","payload","optionsKey","keyId","keyIssuer","keyExpiration","expiresIn","console","warn","kid","kis","kep","pasetoToken","sign","issuer","subject","audience","assertion","validatePayload","validateUrlPayload","validatePaymentInstructionPayload","MissingSecretKey","MissingKid","MissingKis","isKeyExpired","isAfterDate","Date","toISOString","InvalidKepExpired","payloadSchema","object","payment","id","string","address","address_tag","optional","network","enums","Object","values","NetworkCode","coin","is_open","boolean","amount","refine","biggerThanZero","min_amount","max_amount","order","total_amount","coin_code","description","merchant","name","tax_id","image_url","items","array","title","biggerThanOrEqualZero","unit_price","quantity","number","value","length","payloadUrlSchema","url","errors","validate","failure","failures","InvalidPayload","message","PaymentInstructionsReader","read","qrCrypto","publicKey","isValidQr","startsWith","InvalidQrCryptoToken","token","slice","verify","complete","ignoreExp","ignoreIat","InvalidQrCryptoKeyId","InvalidQrCryptoKeyIssuer","ignoreKeyExp"]}